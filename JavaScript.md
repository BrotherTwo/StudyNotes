# 索引

<!-- MarkdownTOC -->

- [JavaScript](#javascript)
  - [数据类型](#数据类型)
    - [1. `typeof` 操作符](#1-typeof-操作符)
    - [2. `undefined` 类型](#2-undefined-类型)
    - [3. `Null` 类型](#3-null-类型)
    - [4. `Boolean` 类型](#4-boolean-类型)
    - [5. `Number` 类型](#5-number-类型)
    - [6. `String` 类型](#6-string-类型)

<!-- /MarkdownTOC -->

***

<a name="javascript"></a>
# JavaScript

<a name="数据类型"></a>
## 数据类型

ECMAScript 中有`5`种简单数据类型（也称为基本数据类型）：`Undefined`、`Null`、`Boolean`、`Number`、`String`  
`1`种复杂数据类型——`Object`

<a name="1-typeof-操作符"></a>
#### 1. `typeof` 操作符

对一个值使用 `typeof` 操作符可能返回下列某个字符串:

* `undefined` ——如果这个值未定义
* `boolean` ——如果这个值是布尔值
* `string` ——如果这个值是字符串
* `number` ——如果这个值是数值
* `object` ——如果这个值是对象或 `null`
* `function` ——如果这个值是函数

<a name="2-undefined-类型"></a>
#### 2. `undefined` 类型

在使用 `var` 声明变量但未对其加以初始化时,
这个变量的值就是 `undefined`

<a name="3-null-类型"></a>
#### 3. `Null` 类型

`undefined` 值是派生自 `null` 值的,因此 ECMA-262 规定对它们的相等性测试要返回 `true` :

    alert(null == undefined);    //true

只要意在保存对象的变量还没有真正保存对象,就应该明确地让该变量保存 `null` 值。这样做不仅可以
体现 `null` 作为空对象指针的惯例,而且也有助于进一步区分 `null` 和 `undefined`

<a name="4-boolean-类型"></a>
#### 4. `Boolean` 类型

`Boolean` 类型是 ECMAScript 中使用得最多的一种类型,该类型只有两个字面值: `true` 和 `false`  
这两个值与数字值不是一回事,因此 `true` 不一定等于 `1`,而 `false` 也不一定等于 `0`  
要将一个值转换为其对应的 `Boolean` 值,可以调用转型函数 `Boolean()` ,如下例所示:

    var message = "Hello world!";
    var messageAsBoolean = Boolean(message);

|数据类型|转换为true的值|转换为false的值|
|-------|-------------|-------------|
|Boolean|true|false|
|String |任何非空字符串 |""（空字符串）|
|Number |任何非零数字值（包括无穷大）|0和NaN|
|Object |任何对象      |null|
|Undefined|n/a        |undefined    |

<a name="5-number-类型"></a>
#### 5. `Number` 类型

>鉴于 JavaScript 中保存数值的方式,可以保存正零(+0)和负零(-0)，正零和负零被认为相等

除了以十进制表示外,整数还可以通过八进制(以 8 为基数)或十六进制(以 16 为基数)的字面值来表示。其中,八进制字面值的第一位必须是零(0),然后是八进制数字序列(0~7)。如果字面值中的数值超出了范围,那么前导零将被忽略,后面的数值将被当作十进制数值解析。请看下面的例子:

    var octalNum1 = 070;     // 八进制的 56
    var octalNum2 = 079;     // 无效的八进制数值——解析为 8
    var octalNum3 = 08;      // 无效的八进制数值——解析为 79

>八进制字面量在严格模式下是无效的,会导致支持的 JavaScript 引擎抛出错误。

六进制字面值的前两位必须是 0x,后跟任何十六进制数字(0~9 及 A~F)。其中,字母 A~F 可以大写,也可以小写。如下面的例子所示:

    var hexNum1 = 0xA;       // 十六进制的 10
    var hexNum2 = 0x1f;      // 十六进制的 31

>在进行算术计算时,所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。

##### 1. 浮点数值

由于保存浮点数值需要的内存空间是保存整数值的两倍,因此 _ECMAScript_ 会不失时机地将浮点数值转换为整数值。显然,如果小数点后面没有跟任何数字,那么这个数值就可以作为整数值来保存。同样地,如果浮点数值本身表示的就是一个整数(如 1.0),那么该值也会被转换为整数,如下面的例子所示:

    var floatNum1 = 1.;      // 小数点后面没有数字——解析为 1
    var floatNum2 = 10.0;    // 整数——解析为 10

>永远不要测试某个特定的浮点数值

##### 2. 数值范围

_ECMAScript_ 能够表示的最小数值保存在 `Number.MIN_VALUE` 中——在大多数浏览器中,这个值是 `5e-324`；能够表示的最大数值保存在 `Number.MAX_VALUE`中——在大多数浏览器中,这个值是 `1.7976931348623157e+308`。如果某次计算的结果得到了一个超出 JavaScript 数值范围的值,那么这个数值将被自动转换成特殊的 `Infinity` 值。具体来说,如果这个数值是负数,则会被转换成 `-Infinity` (负无穷),如果这个数值是正数,则会被转换成 `Infinity` (正无穷)。

如上所述,如果某次计算返回了正或负的 Infinity 值,那么该值将无法继续参与下一次的计算,因为 Infinity 不是能够参与计算的数值。要想确定一个数值是不是有穷的(换句话说,是不是位于最小和最大的数值之间),可以使用 isFinite() 函数。这个函数在参数位于最小与最大数值之间时会返回 true ,如下面的例子所示:

    var result = Number.MAX_VALUE + Number.MAX_VALUE;
    alert(isFinite(result)); //false

>访问 `Number.NEGATIVE_INFINITY` 和 `Number.POSITIVE_INFINITY` 也可以得到负和正 `Infinity` 的值。可以想见,这两个属性中分别保存着 `-Infinity` 和 `Infinity` 。

##### 3. _NaN_ (Not a Number)

`NaN` ,即非数值(Not a Number)是一个特殊的数值,这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会抛出错误了),`NaN` 本身有两个非同寻常的特点：

* 任何涉及 `NaN` 的操作（例如 `NaN/10`）都会返回 `NaN`，这个特点在多步计算中有可能导致问题
* `NaN` 与任何值都不相等，包括 `NaN` 本身，例如：`alert(NaN == NaN); //false `

>实际上只有 `0` 除以 `0` 才会返回 `NaN`,正数除以 `0` 返回 `Infinity`,负数除以 `0` 返回`-Infinity。`

针对 `NaN` 的这两个特点, _ECMAScript_ 定义了 `isNaN()` 函数。这个函数接受一个参数,该参数可以是任何类型,而函数会帮我们确定这个参数是否“__不是数值__”。 `isNaN()` 在接收到一个值之后,会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值,例如字符串 `"10"` 或 `Boolean` 值。而任何不能被转换为数值的值都会导致这个函数返回 `true` 。请看下面的例子:

    alert(isNaN(NaN));      //true
    alert(isNaN(10));       //false（10是一个数值）
    alert(isNaN("10"));     //false（可以被转换成数值10）
    alert(isNaN("blue"));   //true（不能转换成数值）
    alert(isNaN(true));     //false（可以被转换成数值1）

>尽管有点儿不可思议,但 `isNaN()` 确实也适用于对象。在基于对象调用 `isNaN()` 函数时,会首先调用对象的 `valueOf()` 方法,然后确定该方法返回的值是否可以转换为数值。如果不能,则基于这个返回值再调用 `toString()` 方法,再测试返回值。而这个过程也是 _ECMAScript_ 中内置函数和操作符的一般执行流程。

##### 4. 数值转换

有 `3` 个函数可以把非数值转换为数值: `Number()` 、 `parseInt()` 和 `parseFloat()`

`Number()`函数的转换规则如下：

* 如果是 `Boolean` 值, `true` 和 `false` 将分别被转换为 `1` 和 `0`
* 如果是数字值,只是简单的传入和返回
* 如果是 `null` 值,返回 `0`
* 如果是 `undefined` ,返回 `NaN`
* 如果是字符串,遵循下列规则:
    * 如果字符串中只包含数字(包括前面带正号或负号的情况),则将其转换为十进制数值,即 "1"会变成 1, "123" 会变成 123,而 "011" 会变成 11(__注意:__前导的零被忽略了);
    * 如果字符串中包含有效的浮点格式,如 "1.1" ,则将其转换为对应的浮点数值(同样,也会忽略前导零);
    * 如果字符串中包含有效的十六进制格式,例如 "0xf" ,则将其转换为相同大小的十进制整数值;
    * 如果字符串是空的(不包含任何字符),则将其转换为 `0`;
    * 如果字符串中包含除上述格式之外的字符,则将其转换为 `NaN`
* 如果是对象,则调用对象的 `valueOf()` 方法,然后依照前面的规则转换返回的值。如果转换的结果是 `NaN` ,则调用对象的 `toString()` 方法,后再次依照前面的规则转换返回的字符
串值

>一元加操作符的操作与 `Number()` 函数相同

`parseInt()` 函数的转换规则如下：  
函数在转换字符串时,更多的是看其是否符合数值模式。它会忽略字符串前面的空格,直至找到第一个非空格字符。

* 如果第一个字符不是数字字符或者负号, `parseInt()` 就会返回 `NaN` ;也就是说,用 `parseInt()` 转换空字符串 `""` 会返回 `NaN` ( `Number()` 对空字符返回 `0`)。
* 如果第一个字符是数字字符, `parseInt()` 会继续解析第二个字符,直到解析完所有后续字符或者遇到了一个非数字字符。例如, "1234blue" 会被转换为 1234,因为 "blue" 会被完全忽略。类似地, "22.5"
会被转换为 22,因为小数点并不是有效的数字字符。
* 如果字符串中的第一个字符是数字字符, parseInt() 也能够识别出各种整数格式(即十进制、八进制和十六进制数)。也就是说,如果字符串以 "0x" 开头且后跟数字字符,就会将其当作一个十六进制整数;如果字符串以 "0" 开头且后跟数字字符,则会将其当作一个八进制数来解析。

>在 ECMAScript 3 JavaScript 引擎中, "070" 被当成八进制字面量,因此转换后的值是十进制的 56。而在 ECMAScript 5 JavaScript 引擎中, `parseInt()` 已经不具有解析八进制值的能力,因此前导的零会被认为无效,从而将这个值当成 "70" ,结果就得到十进制的 70。在 ECMAScript 5 中,即使是在非严格模式下也会如此。  
为了消除在使用 `parseInt()` 函数时可能导致的上述困惑,可以为这个函数提供第二个参数:转换时使用的基数(即多少进制)。如果知道要解析的值是十六进制格式的字符串,那么指定基数 16 作为第二个参数,可以保证得到正确的结果，例如：`parseInt("0xAF,16");` `parseInt("AF,16");`  
不指定基数意味着让 parseInt() 决定如何解析输入的字符串,因此为了避免错误的解析,建议无论在什么情况下都明确指定基数。

`parseFloat()` 函数的转换规则如下：  
与 `parseInt()` 函数类似, `parseFloat()` 也是从第一个字符(位置 `0`)开始解析每个字符。而且也是一直解析到字符串末尾,或者解析到遇见一个无效的浮点数字字符为止。也就是说,字符串中的第一个小数点是有效的,而第二个小数点就是无效的了,因此它后面的字符串将被忽略。举例来说,"22.34.5" 将会被转换为 22.34  
除了第一个小数点有效之外, `parseFloat()` 与 `parseInt()` 的第二个区别在于它始终都会忽略前导的零。 `parseFloat()` 可以识别前面讨论过的所有浮点数值格式,也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成 `0`。由于 `parseFloat()` 只解析十进制值,因此它没有用第二个参数指定基数的用法。  
最后还要注意一点:如果字符串包含的是一个可解析为整数的数(没有小数点,或者小数点后都是零), `parseFloat()` 会返回整数。

<a name="6-string-类型"></a>
#### 6. `String` 类型

`String` 类型用于表示由零或多个 16 位 `Unicode` 字符组成的字符序列,即字符串。字符串可以由双引号(")或单引号(')表示

##### 1. 字符字面量

`String` 数据类型包含一些特殊的字符字面量,也叫转义序列,用于表示非打印字符,或者具有其他用途的字符。这些字符字面量如下表所示:

|字面量|含义|
|-----|---|
|\n|换行|
|\t|制表|
|\b|空格|
|\r|回车|
|\f|进纸|
|\\\|斜杠|
|\'|单引号，在用单引号表示的字符串中使用。例如: 'He said, \'hey.\''|
|\"|双引号，在用双引号表示的字符串中使用。例如: "He said, \"hey.\""|
|\xnn|以十六进制代码 nn 表示的一个字符(其中 n 为0~F)。例如, \x41 表示 "A"|
|\unnn|以十六进制代码 nnnn 表示的一个Unicode字符(其中 n 为0~F)。例如, \u03a3 表示希腊字符Σ|
