# 索引

<!-- MarkdownTOC -->

- [JavaScript](#javascript)
    - [第3章 语法、关键保留字及变量](#第3章-语法、关键保留字及变量)
    - [第4章 数据类型](#第4章-数据类型)
        - [1. `typeof` 操作符](#1-typeof-操作符)
        - [2. `undefined` 类型](#2-undefined-类型)
        - [3. `Null` 类型](#3-null-类型)
        - [4. `Boolean` 类型](#4-boolean-类型)
        - [5. `Number` 类型](#5-number-类型)
        - [6. `String` 类型](#6-string-类型)
        - [7. `Object` 类型](#7-object-类型)
    - [操作符](#操作符)
        - [1. 一元操作符](#1-一元操作符)
        - [2. 位操作符](#2-位操作符)
        - [3. 布尔操作符](#3-布尔操作符)
        - [4. 乘性操作符](#4-乘性操作符)
        - [5. 加性操作符](#5-加性操作符)
        - [6. 关系操作符](#6-关系操作符)
        - [7. 相等操作符](#7-相等操作符)
        - [8. 条件操作符](#8-条件操作符)
        - [9. 赋值操作符](#9-赋值操作符)
        - [10.逗号操作符](#10逗号操作符)
    - [语句](#语句)
        - [ 1. `if` 语句](#-1-if-语句)
        - [2. `do-while` 语句](#2-do-while-语句)
        - [3. `while` 语句](#3-while-语句)
        - [4. `for` 语句](#4-for-语句)
        - [5. `for-in` 语句](#5-for-in-语句)
        - [6. `label` 语句](#6-label-语句)
        - [7. `break` 和 `continue` 语句](#7-break-和-continue-语句)
        - [8. `with` 语句](#8-with-语句)
        - [ 9. `switch` 语句](#-9-switch-语句)
    - [函数](#函数)
        - [1. 理解参数](#1-理解参数)
        - [2. 没有重载](#2-没有重载)
    - [引用类型](#引用类型)
        - [`Date` 类型](#date-类型)

<!-- /MarkdownTOC -->

***

<a name="javascript"></a>
# JavaScript

[树形图笔记](https://coggle.it/diagram/VjR7Lm_Q0gtu4Qd0)

***

<a name="第3章-语法、关键保留字及变量"></a>
## 第3章 语法、关键保留字及变量

* 区分大小写： `text` 和 `Text` 是两种不同的标识符
* 标识符组成开头： a（字母）、_ 、 $
* 其他组成： a（字母）、_ 、 $、数字
* 不能把关键字、保留字，如`true` `false` `null`作为标识符
* 关键字 程序中已经开始使用的字符，如`var`

|字面量|示例|
|---|---|
|数字字面量|100|
|字符串字面量|'李'|
|布尔值字面量|`false` `true`|
|正则表达式|`/js/gi`|
|对象字面量|`null`|
|对象字面量表达式|{x:1,y:2}|
|数组字面量表达式|[1,2,3,4,5]|

变量

* `var box` 声明变量
* `var box = 100；` 声明变量并初始化
* `alert(box)` 以弹窗的方式输出`box`的值
* 不需要重复的使用`var`声明一个变量，只不过是一个赋值操作，并不会报错，但没必要这么做，如下：

```js
    var box = 100           var box = 100；
    var box ='Lee'          box = 'Lee';
```

***

<a name="第4章-数据类型"></a>
## 第4章 数据类型

ECMAScript 中有`5`种简单数据类型（也称为基本数据类型）：`Undefined`、`Null`、`Boolean`、`Number`、`String`  
`1`种复杂数据类型——`Object`

<a name="1-typeof-操作符"></a>
#### 1. `typeof` 操作符

`typeof` 操作符是用来检测变量的数据类型。对于值或者变量使用`typeof`操作符会返回如下字符串:

|字符串|描述|
|---|:---:|
| `undefined` |未定义       |
| `boolean`   |布尔值       |
| `string`    |字符串       |
| `number`    |数值        |
| `object`    |对象或`null`|
| `function`  |函数        |


```js
var box；
alert(typeof box);
//box是 Undefined 类型，值是 undefined ，类型返回的字符串是 undefined

var box = true；
alert(typeof box);
//box是 Boolean 类型，值是 true ，类型返回的字符串是 boolean

var box = 'Lee';
alert(typeof box);
//box是 String 类型，值是 'Lee' ，类型返回的字符串是 string

var box = 250;
alert(typeof box);
//box是 Number 类型，值是 250 ，类型返回的字符串是 number

var box = {};
alert(typeof box);
//box是 Object 类型，值是 [object Object] ，类型返回的字符串是 object

var box = new Object();
alert(box);
//box是 Object 类型，值是 [object Object] ，类型返回的字符串是 object

var box = null;
alert(typeof box);
//box是 Null 类型，值是 null ，类型返回的字符串是 object

function box() {

}
alert(typeof box);
//box是 Function 类型，值是 function box() {} ，类型返回的字符串是 function

alert(typeof new Object());
//可以直接使用字面量
```

>空的对象：表示这个对象创建了，里面没有东西  
空对象：表示没有创建，就是一个`null`

<a name="2-undefined-类型"></a>
#### 2. `undefined` 类型

在使用 `var` 声明变量但未对其加以初始化时,
这个变量的值就是 `undefined`

>我们没有必要显式的给一个变量赋值为`undefined`，因为没有赋值的变量会隐式的（自动的）赋值为`undefined`；而`undefined`主要的目的是为了用于比较，_ECMAScript_第3版之前并没有引入这个值，引入之后为了正式区分空对象与未经初始化的变量。  
未初始化的变量与根本不存在的变量（为声明的变量）也是不一样的。

```js
var box;
alert(age);    //age is not defined
alert(typeof box);
alert(typeof age);
```
`typeof box` `typeof age` 都返回的 `undefined`。 从逻辑上思考，他们的值，一个是 `undefined`，一个报错；他们的类型，却都是`undefined`。所以，在定义变量的时候，尽可能的不要只声明，不赋值。

<a name="3-null-类型"></a>
#### 3. `Null` 类型

`undefined` 值是派生自 `null` 值的,因此 ECMA-262 规定对它们的相等性测试要返回 `true` :

    alert(null == undefined);    //true

只要意在保存对象的变量还没有真正保存对象,就应该明确地让该变量保存 `null` 值。这样做不仅可以
体现 `null` 作为空对象指针的惯例,而且也有助于进一步区分 `null` 和 `undefined`

```js
var box = null；
//这个表示，你还没有创建对象，但先声明了对象引用而必须初始化的结果
//还没来得及创建对象，先声明一个对象的变量放在那边，默认初始化为 null

var box = null ;
box = {
  1:1
};
alert(box);

var box = '';
//创建一个字符串变量，一开始不知道初始化什么字符串，可以先给一个空字符串初始化

var box = 0;
//数值初始化，一般用0

var box = false；
//布尔值初始化，一般一开始用 false 或者 true

alert(undefined == null);   //true
alert(undefined === null);  //false
alert(typeof undefined == typeof null);  //false
```

<a name="4-boolean-类型"></a>
#### 4. `Boolean` 类型

`Boolean` 类型是 ECMAScript 中使用得最多的一种类型,该类型只有两个字面值: `true` 和 `false`  
这两个值与数字值不是一回事,因此 `true` 不一定等于 `1`,而 `false` 也不一定等于 `0`  
要将一个值转换为其对应的 `Boolean` 值,可以调用转型函数 `Boolean()` ,如下例所示:

    var message = "Hello world!";
    var messageAsBoolean = Boolean(message);

```js
var box = true;
alert(typeof box == typeof 1);    //true
alert(typeof box === typeof 1);    //false

var box = 'Lee';
alert(Boolean(box));    //true
var box = '';
alert(Boolean(box));    //false
//上面的 Boolean 是一种显示转换，属于强制性转换。

//下面为 隐式转换，在 if 条件语句里面的条件判断，就存在隐式转换
var box = '';
if(box){        //条件语句里的()里必须是布尔值，true或者false
  alert('true');
}else{
  alert('false');
}
```

转换成`Boolean`类型的规则

|数据类型|转换为true的值|转换为false的值|
|----|-----|-----|
|Boolean|true|false|
|String|任何非空字符串|空字符串|
|Number|任何非零数字值（包括无穷大）|0 和 NaN|
|Object|任何对象|null|
|Undefined| |undefined|

<a name="5-number-类型"></a>
#### 5. `Number` 类型

>鉴于 JavaScript 中保存数值的方式,可以保存正零(+0)和负零(-0)，正零和负零被认为相等

除了以十进制表示外,整数还可以通过八进制(以 8 为基数)或十六进制(以 16 为基数)的字面值来表示。其中,八进制字面值的第一位必须是零(0),然后是八进制数字序列(0~7)。如果字面值中的数值超出了范围,那么前导零将被忽略,后面的数值将被当作十进制数值解析。请看下面的例子:

    var octalNum1 = 070;     // 八进制的 56
    var octalNum2 = 079;     // 无效的八进制数值——解析为 79
    var octalNum3 = 08;      // 无效的八进制数值——解析为 8

>八进制字面量在严格模式下是无效的,会导致支持的 JavaScript 引擎抛出错误。

六进制字面值的前两位必须是 0x,后跟任何十六进制数字(0~9 及 A~F)。其中,字母 A~F 可以大写,也可以小写。如下面的例子所示:

    var hexNum1 = 0xA;       // 十六进制的 10
    var hexNum2 = 0x1f;      // 十六进制的 31

>在进行算术计算时,所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。

##### 1. 浮点数值

由于保存浮点数值需要的内存空间是保存整数值的两倍,因此 _ECMAScript_ 会不失时机地将浮点数值转换为整数值。显然,如果小数点后面没有跟任何数字,那么这个数值就可以作为整数值来保存。同样地,如果浮点数值本身表示的就是一个整数(如 1.0),那么该值也会被转换为整数,如下面的例子所示:

    var floatNum1 = 1.;      // 小数点后面没有数字——解析为 1
    var floatNum2 = 10.0;    // 整数——解析为 10

>永远不要测试某个特定的浮点数值

##### 2. 数值范围

_ECMAScript_ 能够表示的最小数值保存在 `Number.MIN_VALUE` 中——在大多数浏览器中,这个值是 `5e-324`；能够表示的最大数值保存在 `Number.MAX_VALUE`中——在大多数浏览器中,这个值是 `1.7976931348623157e+308`。如果某次计算的结果得到了一个超出 JavaScript 数值范围的值,那么这个数值将被自动转换成特殊的 `Infinity` 值。具体来说,如果这个数值是负数,则会被转换成 `-Infinity` (负无穷),如果这个数值是正数,则会被转换成 `Infinity` (正无穷)。

如上所述,如果某次计算返回了正或负的 Infinity 值,那么该值将无法继续参与下一次的计算,因为 Infinity 不是能够参与计算的数值。要想确定一个数值是不是有穷的(换句话说,是不是位于最小和最大的数值之间),可以使用 isFinite() 函数。这个函数在参数位于最小与最大数值之间时会返回 true ,如下面的例子所示:

    var result = Number.MAX_VALUE + Number.MAX_VALUE;
    alert(isFinite(result)); //false

>访问 `Number.NEGATIVE_INFINITY` 和 `Number.POSITIVE_INFINITY` 也可以得到负和正 `Infinity` 的值。可以想见,这两个属性中分别保存着 `-Infinity` 和 `Infinity` 。

##### 3. _NaN_ (Not a Number)

`NaN` ,即非数值(Not a Number)是一个特殊的数值,这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会抛出错误了),`NaN` 本身有两个非同寻常的特点：

* 任何涉及 `NaN` 的操作（例如 `NaN/10`）都会返回 `NaN`，这个特点在多步计算中有可能导致问题
* `NaN` 与任何值都不相等，包括 `NaN` 本身，例如：`alert(NaN == NaN); //false `

>实际上只有 `0` 除以 `0` 才会返回 `NaN`,正数除以 `0` 返回 `Infinity`,负数除以 `0` 返回`-Infinity。`

针对 `NaN` 的这两个特点, _ECMAScript_ 定义了 `isNaN()` 函数。这个函数接受一个参数,该参数可以是任何类型,而函数会帮我们确定这个参数是否“__不是数值__”。 `isNaN()` 在接收到一个值之后,会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值,例如字符串 `"10"` 或 `Boolean` 值。而任何不能被转换为数值的值都会导致这个函数返回 `true` 。请看下面的例子:

    alert(isNaN(NaN));      //true
    alert(isNaN(10));       //false（10是一个数值）
    alert(isNaN("10"));     //false（可以被转换成数值10）
    alert(isNaN("blue"));   //true（不能转换成数值）
    alert(isNaN(true));     //false（可以被转换成数值1）

>尽管有点儿不可思议,但 `isNaN()` 确实也适用于对象。在基于对象调用 `isNaN()` 函数时,会首先调用对象的 `valueOf()` 方法,然后确定该方法返回的值是否可以转换为数值。如果不能,则基于这个返回值再调用 `toString()` 方法,再测试返回值。而这个过程也是 _ECMAScript_ 中内置函数和操作符的一般执行流程。

##### 4. 数值转换

有 `3` 个函数可以把非数值转换为数值: `Number()` 、 `parseInt()` 和 `parseFloat()`

`Number()`函数的转换规则如下：

* 如果是 `Boolean` 值, `true` 和 `false` 将分别被转换为 `1` 和 `0`
* 如果是数字值,只是简单的传入和返回
* 如果是 `null` 值,返回 `0`
* 如果是 `undefined` ,返回 `NaN`
* 如果是字符串,遵循下列规则:
    * 如果字符串中只包含数字(包括前面带正号或负号的情况),则将其转换为十进制数值,即 "1"会变成 1, "123" 会变成 123,而 "011" 会变成 11(__注意:__前导的零被忽略了);
    * 如果字符串中包含有效的浮点格式,如 "1.1" ,则将其转换为对应的浮点数值(同样,也会忽略前导零);
    * 如果字符串中包含有效的十六进制格式,例如 "0xf" ,则将其转换为相同大小的十进制整数值;
    * 如果字符串是空的(不包含任何字符),则将其转换为 `0`;
    * 如果字符串中包含除上述格式之外的字符,则将其转换为 `NaN`
* 如果是对象,则调用对象的 `valueOf()` 方法,然后依照前面的规则转换返回的值。如果转换的结果是 `NaN` ,则调用对象的 `toString()` 方法,后再次依照前面的规则转换返回的字符
串值

>一元加操作符的操作与 `Number()` 函数相同

`parseInt()` 函数的转换规则如下：  
函数在转换字符串时,更多的是看其是否符合数值模式。它会忽略字符串前面的空格,直至找到第一个非空格字符。

* 如果第一个字符不是数字字符或者负号, `parseInt()` 就会返回 `NaN` ;也就是说,用 `parseInt()` 转换空字符串 `""` 会返回 `NaN` ( `Number()` 对空字符返回 `0`)。
* 如果第一个字符是数字字符, `parseInt()` 会继续解析第二个字符,直到解析完所有后续字符或者遇到了一个非数字字符。例如, "1234blue" 会被转换为 1234,因为 "blue" 会被完全忽略。类似地, "22.5"
会被转换为 22,因为小数点并不是有效的数字字符。
* 如果字符串中的第一个字符是数字字符, parseInt() 也能够识别出各种整数格式(即十进制、八进制和十六进制数)。也就是说,如果字符串以 "0x" 开头且后跟数字字符,就会将其当作一个十六进制整数;如果字符串以 "0" 开头且后跟数字字符,则会将其当作一个八进制数来解析。

>在 ECMAScript 3 JavaScript 引擎中, "070" 被当成八进制字面量,因此转换后的值是十进制的 56。而在 ECMAScript 5 JavaScript 引擎中, `parseInt()` 已经不具有解析八进制值的能力,因此前导的零会被认为无效,从而将这个值当成 "70" ,结果就得到十进制的 70。在 ECMAScript 5 中,即使是在非严格模式下也会如此。  
为了消除在使用 `parseInt()` 函数时可能导致的上述困惑,可以为这个函数提供第二个参数:转换时使用的基数(即多少进制)。如果知道要解析的值是十六进制格式的字符串,那么指定基数 16 作为第二个参数,可以保证得到正确的结果，例如：`parseInt("0xAF,16");` `parseInt("AF,16");`  
不指定基数意味着让 parseInt() 决定如何解析输入的字符串,因此为了避免错误的解析,建议无论在什么情况下都明确指定基数。

`parseFloat()` 函数的转换规则如下：  
与 `parseInt()` 函数类似, `parseFloat()` 也是从第一个字符(位置 `0`)开始解析每个字符。而且也是一直解析到字符串末尾,或者解析到遇见一个无效的浮点数字字符为止。也就是说,字符串中的第一个小数点是有效的,而第二个小数点就是无效的了,因此它后面的字符串将被忽略。举例来说,"22.34.5" 将会被转换为 22.34  
除了第一个小数点有效之外, `parseFloat()` 与 `parseInt()` 的第二个区别在于它始终都会忽略前导的零。 `parseFloat()` 可以识别前面讨论过的所有浮点数值格式,也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成 `0`。由于 `parseFloat()` 只解析十进制值,因此它没有用第二个参数指定基数的用法。  
最后还要注意一点:如果字符串包含的是一个可解析为整数的数(没有小数点,或者小数点后都是零), `parseFloat()` 会返回整数。

<a name="6-string-类型"></a>
#### 6. `String` 类型

`String` 类型用于表示由零或多个 16 位 `Unicode` 字符组成的字符序列,即字符串。字符串可以由双引号(")或单引号(')表示

##### 1. 字符字面量

`String` 数据类型包含一些特殊的字符字面量,也叫转义序列,用于表示非打印字符,或者具有其他用途的字符。这些字符字面量如下表所示:

|字面量|含义|
|-----|---|
|\n|换行|
|\t|制表|
|\b|空格|
|\r|回车|
|\f|进纸|
|\\\|斜杠|
|\'|单引号，在用单引号表示的字符串中使用。例如: 'He said, \'hey.\''|
|\"|双引号，在用双引号表示的字符串中使用。例如: "He said, \"hey.\""|
|\xnn|以十六进制代码 nn 表示的一个字符(其中 n 为0~F)。例如, \x41 表示 "A"|
|\unnn|以十六进制代码 nnnn 表示的一个Unicode字符(其中 n 为0~F)，例如, \u03a3 表示希腊字符Σ|

>这些字符字面量可以出现在字符串中的任意位置,而且也将被作为__*`1`*__个字符来解析

##### 2. 字符串的特点

_ECMAScript_ 中的字符串是不可变的,也就是说,字符串一旦创建,它们的值就不能改变。要改变某个变量保存的字符串,首先要销毁原来的字符串,然后再用另一个包含新值的字符串填充该变量

##### 3. 转换字符串

数值、布尔值、对象和字符串值(没错,每个字符串也都有一个 `toString()` 方法,该方法返回字符串的一个副本)都有 `toString()` 方法。但 `null` 和 `undefined` 值没有这个方法。  
在调用数值的 `toString()` 方法时,可以传递一个参数:输出数值的基数。默认情况下, `toString()` 方法以十进制格式返回数值的字符串表示。而通过传递基数, `toString()` 可以输出以二进制、八进制、十六进制,乃至其他任意有效进制格式表示的字符串值。  

    var num = 10;
    alert(num.toString());        //"10"
    alert(num.toString(2));       //"1010"
    alert(num.toString(8));       //"12"
    alert(num.toString(10));      //"10"
    alert(num.toString(16));      //"a"

在不知道要转换的值是不是 `null` 或 `undefined` 的情况下,还可以使用转型函数 `String()` ,这个函数能够将任何类型的值转换为字符串。 `String()` 函数遵循下列转换规则:

* 如果值有 `toString()` 方法,则调用该方法(没有参数)并返回相应的结果;
* 如果值是 `null` ,则返回 "null" ;
* 如果值是 `undefined` ,则返回 "undefined" 。

下面转换了 4 个值:数值、布尔值、 null 和 undefined 。数值和布尔值的转换结果与调用 `toString()` 方法得到的结果相同。因为 null 和 undefined 没有 `toString()` 方法,所以 `String()` 函数就返回了这两个值的字面量。

    var value1 = 10;
    var value2 = true;
    var value3 = null;
    var value4;

    alert(String(value1));      //"10"
    alert(String(value2));      //"true"
    alert(String(value3));      //"null"
    alert(String(value4));      //"undefined"

<a name="7-object-类型"></a>
#### 7. `Object` 类型

_ECMAScript_ 中的对象其实就是一组数据和功能的集合。对象可以通过执行 `new` 操作符后跟要创建的对象类型的名称来创建。而创建 `Object` 类型的实例并为其添加属性和(或)方法,就可以创建自定义对象。

`Object` 的每个实例都具有下列属性和方法：

* `constructor` :保存着用于创建当前对象的函数。对于前面的例子而言,构造函数(`constructor`) 就是 `Object()`
* `hasOwnProperty(propertyName)` :用于检查给定的属性在当前对象实例中(而不是在实例的原型中)是否存在。其中,作为参数的属性名( `propertyName` )必须以字符串形式指定(例如: `o.hasOwnProperty("name")` )
* `isPrototypeOf(object)` :用于检查传入的对象是否是传入对象的原型(第 5 章将讨论原型)
* `propertyIsEnumerable(propertyName)` :用于检查给定的属性是否能够使用 `for-in` 语句(本章后面将会讨论)来枚举。与 `hasOwnProperty()` 方法一样,作为参数的属性名必须以字符串形式指定
* `toLocaleString()` :返回对象的字符串表示,该字符串与执行环境的地区对应
* `toString()` :返回对象的字符串表示
* `valueOf()` :返回对象的字符串、数值或布尔值表示。通常与 `toString()` 方法的返回值相同

***

<a name="操作符"></a>
## 操作符

_ECMA-262_ 描述了一组用于操作数据值的操作符,包括算术操作符(如加号和减号)、位操作符、关系操作符和相等操作符。_ECMAScript_ 操作符的与众不同之处在于,它们能够适用于很多值,例如字符串、数字值、布尔值,甚至对象。不过,在应用于对象时, 相应的操作符通常都会调用对象的 `valueOf()` 和(或) `toString()` 方法,以便取得可以操作的值。

<a name="1-一元操作符"></a>
#### 1. 一元操作符

只能操作一个值的操作符叫做一元操作符。

##### 1.递增和递减操作符
递增`++`和递减`--`操作符各有两个版本：前置型和后置型。

不仅适用于整数,还可以用于字符串、布尔值、浮点数值和对象。在应用于不同的值时,递增和递减操作符遵循下列规则：

* 在应用于一个包含有效数字字符的字符串时,先将其转换为数字值,再执行加减 1 的操作。字符串变量变成数值变量
* 在应用于一个不包含有效数字字符的字符串时,将变量的值设置为 `NaN` 字符串变量变成数值变量
* 在应用于布尔值 `false` 时,先将其转换为 0 再执行加减 1 的操作。布尔值变量变成数值变量。
* 在应用于布尔值 `true` 时,先将其转换为 1 再执行加减 1 的操作。布尔值变量变成数值变量。
* 在应用于浮点数值时,执行加减 1 的操作。
* 在应用于对象时,先调用对象的 `valueOf()`  方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是 `NaN` ,则在调用 `toString()` 方法后再应用前述规则。对象变量变成数值变量。

<a name="2-一元加和减操作符"></a>
##### 2. 一元加和减操作符
在对非数值应用一元加`+`操作符时,该操作符会像 `Number()` 转型函数一样对这个值执行转换。换句话说,布尔值 `false` 和 `true` 将被转换为 `0` 和 `1`,字符串值会被按照一组特殊的规则进行解析,而对象是先调用它们的 `valueOf()` 和(或) `toString()` 方法,再转换得到的值。  
一元减`-`操作符主要用于表示负数,例如将 `1` 转换成 `-1`。而当应用于非数值时,一元减操作符遵循与一元加操作符相同的规则,最后再将得到的数值转换为负数。

>元加和减操作符主要用于基本的算术运算,也可以用于转换数据类型。

<a name="2-位操作符"></a>
#### 2. 位操作符

位操作符用于在最基本的层次上,即按内存中表示数值的位来操作数值。  
ECMAScript 中的所有数值都以 IEEE-754 64 位格式存储,但位操作符并不直接操作 64 位的值。而是先将 64 位的值转换成 32 位的整数,然后执行操作,最后再将结果转换回 64 位。对于开发人员来说,由于 64 位存储格式是透明的,因此整个过程就像是只存在 32 位的整数一样。

负数同样以二进制码存储,但使用的格式是二进制补码。计算一个数值的二进制补码,需要经过下列 3 个步骤:

    1. 求这个数值绝对值的二进制码
    2. 求二进制反码，即将 0 替换为 1 ，将 1 替换为 0
    3. 得到的二进制反码加 1

>默认情况下,ECMAScript 中的所有整数都是有符号整数。不过,当然也存在无符号整数。对于无符号整数来说,第 32 位不再表示符号,因为无符号整数只能是正数。而且,无符号整数的值可以更大,因为多出的一位不再表示符号,可以用来表示数值。

在 _ECMAScript_ 中,当对数值应用位操作符时,后台会发生如下转换过程:64 位的数值被转换成 32位数值,然后执行位操作,最后再将 32 位的结果转换回 64 位数值。这样,表面上看起来就好像是在操作 32 位数值,就跟在其他语言中以类似方式执行二进制操作一样。但这个转换过程也导致了一个严重的副效应,即在对特殊的 `NaN` 和 `Infinity` 值应用位操作时,这两个值都会被当成 0 来处理。  
如果对非数值应用位操作符,会先使用 `Number()` 函数将该值转换为一个数值(自动完成),然后再应用位操作。得到的结果将是一个数值。

##### 1. 按位非（NOT <kbd>~</kbd>）
按位非操作符由一个波浪线 <kbd>~</kbd> 表示,执行按位非的结果就是返回数值的反码。  
按位非操作的本质:__操作数的负值减 1__。  
由于按位非是在数值表示的最底层执行操作,因此速度更快。

##### 2. 按位与（AND <kbd>&</kbd>）
按位与操作符由一个和号字符 <kbd>&</kbd> 表示,它有两个操作符数。从本质上讲,按位与操作就是将两个数值的每一位对齐,然后根据下表中的规则,对相同位置上的两个数执行 AND 操作:

|第一个数值的位|第二个数值的位|结果|
|:-:|:-:|:-:|
|1|1|1|
|1|0|0|
|0|1|0|
|0|0|0|

##### 3. 按位或（OR <kbd>|</kbd>）
按位或操作符由一个竖线符号 <kbd>|</kbd> 表示,它有两个操作符数。按位或操作遵循下面这个真值表：

|第一个数值的位|第二个数值的位|结果|
|:-:|:-:|:-:|
|1|1|1|
|1|0|1|
|0|1|1|
|0|0|0|

##### 4. 按位异或（XOR <kbd>^</kbd>）
按位异或操作符由一个插入符号 <kbd>^</kbd> 表示,也有两个操作数。以下是按位异或的真值表:

|第一个数值的位|第二个数值的位|结果|
|:-:|:-:|:-:|
|1|1|0|
|1|0|1|
|0|1|1|
|0|0|0|

##### 5. 左移
左移操作符由两个小于号 <kbd><<</kbd> 表示,这个操作符会将数值的所有位向左移动指定的位数。
>左移不会影响操作数的符号位

##### 6. 有符号右移
有符号的右移操作符由两个大于号 <kbd>>></kbd> 表示,这个操作符会将数值向右移动,但保留符号位(即正负号标记)。
>在移位过程中,原数值中也会出现空位。只不过这次的空位出现在原数值的左侧、符号位的右侧。而此时 ECMAScript 会用符号位的值来填充所有空位,以便得到一个完整的值。

##### 7. 无符号右移
无符号右移操作符由 3 个大于号 <kbd>>>></kbd> 表示,这个操作符会将数值的所有 32 位都向右移动。

* 无符号右移是以 0 来填充空位
* 无符号右移操作符会把负数的二进制码当成正数的二进制码。而且,由于负数以其绝对值的二进制补码形式表示,因此就会导致无符号右移后的结果非常之大

<a name="3-布尔操作符"></a>
#### 3. 布尔操作符

布尔操作符一共有 3 个:`非(NOT)` `与(AND)` `或(OR)`

##### 1. 逻辑非
逻辑非操作符由一个叹号 <kbd>!</kbd> 表示,可以应用于 ECMAScript 中的任何值。逻辑非操作符首先会将它的操作数转换为一个布尔值,然后再
对其求反。逻辑非操作符遵循下列规则:

* 如果操作数是一个对象,返回 false ;
* 如果操作数是一个空字符串,返回 true ;
* 如果操作数是一个非空字符串,返回 false ;
* 如果操作数是数值 0,返回 true ;
* 如果操作数是任意非 0 数值(包括 Infinity ),返回 false ;
* 如果操作数是 null ,返回 true ;
* 如果操作数是 NaN ,返回 true ;
* 如果操作数是 undefined ,返回 true 。

例如：

    alert(!false);      //true
    alert(!"blue");     //false
    alert(!0);          //true
    alert(!NaN);        //true
    alert(!"");         //true
    alert(!12345);      //false

逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符,实际上就会模拟 `Boolean()` 转型函数的行为。其中,第一个逻辑非操作会基于无论什么操作数返回一个布尔值,而第二个逻辑非操作则对该布尔值求反,于是就得到了这个值真正对应的布尔值。当然,最终结果与对这个值使用 `Boolean()` 函数相同,如下面的例子所示:

    alert(!!"blue");    //true
    alert(!!0);         //false
    alert(!!NaN);       //false
    alert(!!"");        //false
    alert(!!12345);     //true

##### 2. 逻辑与
逻辑与操作符由两个和号 <kbd>&&</kbd> 表示,有两个操作数,真值表如下:

|第一个操作数|第二个操作数|结果|
|:---:|:---:|:---:|
|true |true |true |
|true |false|false|
|false|true |false|
|false|false|false|

逻辑与操作可以应用于任何类型的操作数,而不仅仅是布尔值。在有一个操作数不是布尔值的情况下,逻辑与操作就不一定返回布尔值;此时,它遵循下列规则:

* 如果第一个操作数是对象,则返回第二个操作数;
* 如果第二个操作数是对象,则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象;
* 如果两个操作数都是对象,则返回第二个操作数;
* 如果有一个操作数是 null ,则返回 null ;
* 如果有一个操作数是 NaN ,则返回 NaN ;
* 如果有一个操作数是 undefined ,则返回 undefined 。

逻辑与操作属于__短路__操作,即如果第一个操作数能够决定结果,那么就不会再对第二个操作数求值。

##### 3. 逻辑或
逻辑或操作符由两个竖线符号 <kbd>||</kbd> 表示,有两个操作数,真值表如下:

|第一个操作数|第二个操作数|结果|
|:---:|:---:|:---:|
|true |true |true |
|true |false|true|
|false|true |true|
|false|false|false|

与逻辑与操作相似,如果有一个操作数不是布尔值,逻辑或也不一定返回布尔值;此时,它遵循下列规则:

* 如果第一个操作数是对象,则返回第一个操作数;
* 如果第一个操作数的求值结果为 false ,则返回第二个操作数;
* 如果两个操作数都是对象,则返回第一个操作数;
* 如果两个操作数都是 null ,则返回 null ;
* 如果两个操作数都是 NaN ,则返回 NaN ;
* 如果两个操作数都是 undefined ,则返回 undefined 。

与逻辑与操作符相似,逻辑或操作符也是__短路__操作符。也就是说,如果第一个操作数的求值结果为true ,就不会对第二个操作数求值了。

我们可以利用逻辑或的这一行为来避免为变量赋 null 或 undefined 值。例如:

    var myObject = preferredObject || backupObject;

在这个例子中,变量 `myObject` 将被赋予等号后面两个值中的一个。变量 `preferredObject` 中包含优先赋给变量 `myObject` 的值,变量 `backupObject` 负责在 `preferredObject` 中不包含有效值的情况下提供后备值。如果 `preferredObject` 的值不是 `null` ,那么它的值将被赋给 `myObject` ;如果是 `null` ,则将 `backupObject` 的值赋给 `myObject` 。

<a name="4-乘性操作符"></a>
#### 4. 乘性操作符

ECMAScript 定义了 3 个乘性操作符:乘法、除法和求模。  
在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某个操作数不是数值,后台会先使用 `Number()` 转型函数将其转换为数值。也就是说,空字符串将被当作 `0`,布尔值 `true` 将被当作 `1`。

##### 1. 乘法
乘法操作符由一个星号 <kbd>*</kbd> 表示,用于计算两个数值的乘积。在处理特殊值的情况下,乘法操作符遵循下列特殊的规则：

* 如果操作数都是数值,执行常规的乘法计算,即两个正数或两个负数相乘的结果还是正数,而如果只有一个操作数有符号,那么结果就是负数。如果乘积超过了 _ECMAScript_ 数值的表示范围,则返回 `Infinity` 或 `-Infinity`
* 如果有一个操作数是 `NaN` ,则结果是 `NaN`
* 如果是 `Infinity` 与 0 相乘,则结果是 `NaN`
* 如果是 `Infinity` 与非 0 数值相乘,则结果是 `Infinity` 或 -`Infinity` ,取决于有符号操作数的符
* 如果是 `Infinity` 与 `Infinity` 相乘,则结果是 `Infinity`
* 如果有一个操作数不是数值,则在后台调用 `Number()` 将其转换为数值,然后再应用上面的规则

##### 2. 除法
除法操作符由一个斜线符号 <kbd>/</kbd> 表示,执行第二个操作数除第一个操作数的计算。除法操作符对特殊的值规则：

* 如果操作数都是数值,执行常规的除法计算,即两个正数或两个负数相除的结果还是正数,而如果只有一个操作数有符号,那么结果就是负数。如果商超过了 _ECMAScript_ 数值的表示范围,则返回 `Infinity` 或 `-Infinity` ;
* 如果有一个操作数是 `NaN` ,则结果是 `NaN` ;
* 如果是 `Infinity` 被 `Infinity` 除,则结果是 `NaN` ;
* 如果是零被零除,则结果是 `NaN` ;
* 如果是非零的有限数被零除,则结果是 `Infinity` 或 `-Infinity` ,取决于有符号操作数的符号;
* 如果是 `Infinity` 被任何非零数值除,则结果是 `Infinity` 或 `-Infinity` ,取决于有符号操作数的符号;
* 如果有一个操作数不是数值,则在后台调用 `Number()` 将其转换为数值,然后再应用上面的规则。

##### 3. 求模
求模(余数)操作符由一个百分号 <kbd>%</kbd> 表示，求模操作符会遵循下列特殊规则来处理特殊的值：

* 如果操作数都是数值,执行常规的除法计算,返回除得的余数
* 如果被除数是无穷大值而除数是有限大的数值,则结果是 `NaN`
* 如果被除数是有限大的数值而除数是零,则结果是 `NaN`
* 如果是 `Infinity` 被 `Infinity` 除,则结果是 `NaN`
* 如果被除数是有限大的数值而除数是无穷大的数值,则结果是被除数
* 如果被除数是零,则结果是零
* 如果有一个操作数不是数值,则在后台调用 `Number()` 将其转换为数值,然后再应用上面的规则

<a name="5-加性操作符"></a>
#### 5. 加性操作符

##### 1. 加法 <kbd>+</kbd>
如果两个操作符都是数值,执行常规的加法计算,然后根据下列规则返回结果:

* 如果有一个操作数是 `NaN` ,则结果是 `NaN`
* 如果是 `Infinity` 加 `Infinity` ,则结果是 `Infinity`
* 如果是 `-Infinity` 加 `-Infinity` ,则结果是 `-Infinity`
* 如果是 `Infinity` 加 `-Infinity` ,则结果是 `NaN`
* 如果是`+0` 加`+0`,则结果是`+0`
* 如果是`-0` 加`-0`,则结果是`-0`
* 如果是`+0` 加`-0`,则结果是`+0`

如果有一个操作数是字符串,那么就要应用如下规则:

* 如果两个操作数都是字符串,则将第二个操作数与第一个操作数拼接起来;
* 如果只有一个操作数是字符串,则将另一个操作数转换为字符串,然后再将两个字符串拼接起来。
* 如果有一个操作数是对象、数值或布尔值,则调用它们的 `toString()` 方法取得相应的字符串值,然后再应用前面关于字符串的规则。对于 `undefined` 和 `null` ,则分别调用 `String()` 函数并取得字符串 "undefined" 和 "null" 。

##### 2. 减法 <kbd>-</kbd>

* 如果两个操作符都是数值,则执行常规的算术减法操作并返回结果
* 如果有一个操作数是 `NaN` ,则结果是 `NaN`
* 如果是 `Infinity` 减 `Infinity` ,则结果是 `NaN`
* 如果是 `-Infinity` 减 `-Infinity` ,则结果是 `NaN`
* 如果是 `Infinity` 减 `-Infinity` ,则结果是 `Infinity`
* 如果是 -`Infinity` 减 `Infinity` ,则结果是 `-Infinity`
* 如果是`+0` 减`+0`,则结果是`+0`
* 如果是`+0` 减`-0`,则结果是`-0`
* 如果是`-0` 减`-0`,则结果是`+0`
* 如果有一个操作数是字符串、布尔值、 null 或 undefined ,则先在后台调用 `Number()` 函数将其转换为数值,然后再根据前面的规则执行减法计算。如果转换的结果是 NaN ,则减法的结果就是 `NaN`
* 如果有一个操作数是对象,则调用对象的 `valueOf()` 方法以取得表示该对象的数值。如果得到的值是 `NaN` ,则减法的结果就是 `NaN` 。如果对象没有 `valueOf()` 方法,则调用其 `toString()`
方法并将得到的字符串转换为数值

<a name="6-关系操作符"></a>
#### 6. 关系操作符
小于 <kbd><</kbd>、大于 <kbd>></kbd>、小于等于 <kbd><=</kbd> 和大于等于 <kbd>>=</kbd> 这几个关系操作符用于对两个值进行比较,返回一个布尔值。  
当关系操作符的操作数使用了非数值时,也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则:

* 如果两个操作数都是数值,则执行数值比较
* 如果两个操作数都是字符串,则比较两个字符串对应的字符编码值
* 如果一个操作数是数值,则将另一个操作数转换为一个数值,然后执行数值比较
* 如果一个操作数是对象,则调用这个对象的 `valueOf()` 方法,用得到的结果按照前面的规则执行比较。如果对象没有 `valueOf()` 方法,则调用 `toString()` 方法,并用得到的结果根据前面的规则执行比较
* 如果一个操作数是布尔值,则先将其转换为数值,然后再执行比较
* 任何操作数与 `NaN` 进行关系比较，结果都为 `false`

<a name="7-相等操作符"></a>
#### 7. 相等操作符

__相等__和__不相等__——先转换再比较  
__全等__和__不全等__——仅比较而不转换

##### 1. 相等和不相等
相等操作符 <kbd>==</kbd> 不相等操作符 <kbd>!=</kbd>  
这两个操作符都会先转换操作数（通常称为__强制转型__），然后比较相等性。

在转换不同的数据类型时,相等和不相等操作符遵循下列基本规则:

* 如果有一个操作数是布尔值,则在比较相等性之前先将其转换为数值——`false` 转换为 `0`,而 `true` 转换为 `1`
* 如果一个操作数是字符串,另一个操作数是数值,在比较相等性之前先将字符串转换为数值
* 如果一个操作数是对象,另一个操作数不是,则调用对象的 `valueOf()` 方法,用得到的基本类型值按照前面的规则进行比较

这两个操作符在进行比较时则要遵循下列规则

* `null` 和 `undefined` 是相等的
* 要比较相等性之前,不能将 `null` 和 `undefined` 转换成其他任何值
* 如果有一个操作数是 `NaN` ,则相等操作符返回 `false` ,而不相等操作符返回 `true` 。__重要提示:__即使两个操作数都是 `NaN` ,相等操作符也返回 `false` ;因为按照规则, `NaN` 不等于 `NaN`
* 如果两个操作数都是对象,则比较它们是不是同一个对象。如果两个操作数都指向同一个对象,则相等操作符返回 `true` ;否则,返回 `false`

下表列出了一些特殊情况及比较结果:

|表达式| 值 |
|:---:|:--:|
|null == undefined|true|
|"NaN" == NaN|false|
|5 == NaN|false|
|NaN == NaN|false|
|NaN != NaN|true|
|false == 0|true|
|true == 1|true|
|true == 2|false|
|undefined == 0|false|
|null == 0|false|
|"5" == 5|true|

##### 2.全等和不全等
除了在比较之前不转换操作数之外,全等和不全等操作符与相等和不相等操作符没有什么区别。  
全等操作符由 3 个等于号 <kbd>===</kbd> 表示,它只在两个操作数未经转换就相等的情况下返回 `true`  
不全等操作符由一个叹号后跟两个等于号 <kbd>!==</kbd> 表示,它在两个操作数未经转换就不相等的情况下返回 `true`

>`null == undefined` 会返回 `true` ,因为它们是类似的值；但 `null === undefined` 会返回 `false` ,因为它们是不同类型的值。

由于相等和不相等操作符存在类型转换问题,而为了保持代码中数据类型的完整
性,推荐使用全等和不全等操作符。

<a name="8-条件操作符"></a>
#### 8. 条件操作符

    variable = boolean_expression ? true_value : false_value;

<a name="9-赋值操作符"></a>
#### 9. 赋值操作符

简单的赋值操作符由等于号 <kbd>=</kbd> 表示,其作用就是把右侧的值赋给左侧的变量

<a name="10逗号操作符"></a>
#### 10.逗号操作符

    var num1=1, num2=2, num3=3;

逗号操作符多用于声明多个变量;但除此之外,逗号操作符还可以用于赋值。在用于赋值时,逗号操作符总会返回表达式中的最后一项

    var num = (5, 1, 4, 8, 0);     // num 的值为 0

***

<a name="语句"></a>
## 语句

<a name="-1-if-语句"></a>
####  1. `if` 语句

    if (condition) statement1 else statement2
    if (condition1) statement1 else if (condition2) statement2 else statement3

<a name="2-do-while-语句"></a>
#### 2. `do-while` 语句
`do-while` 语句是一种后测试循环语句,即只有在循环体中的代码执行之后,才会测试出口条件。换句话说,在对条件表达式求值之前,循环体内的代码至少会被执行一次。

    do {
      statement
    } while (expression);

<a name="3-while-语句"></a>
#### 3. `while` 语句
`while` 语句属于前测试循环语句,也就是说,在循环体内的代码被执行之前,就会对出口条件求值。因此,循环体内的代码有可能永远不会被执行。

    while(expression) statement

<a name="4-for-语句"></a>
#### 4. `for` 语句
`for` 语句也是一种前测试循环语句,但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。

    for (initialization; expression; post-loop-expression) statement

>使用 `while` 循环做不到的,使用 `for` 循环同样也做不到。也就是说, `for` 循环只是把与循环有关的代码集中在了一个位置。

<a name="5-for-in-语句"></a>
#### 5. `for-in` 语句
`for-in` 语句是一种精准的迭代语句,可以用来枚举对象的属性。以下是 `for-in` 语句的语法:

    for (property in expression) statement

<a name="6-label-语句"></a>
#### 6. `label` 语句
使用 label 语句可以在代码中添加标签,以便将来使用。

    label: statement

加标签的语句一般都要与 for 语句等循环语句配合使用。

<a name="7-break-和-continue-语句"></a>
#### 7. `break` 和 `continue` 语句
break 和 continue 语句都可以与 label 语句联合使用,从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下,如下面的例子所示:

```js
var num = 0;

outermost:
for (var i=0; i < 10; i++) {
  for (var j=0; j < 10; j++) {
    if (i == 5 && j == 5) {
      break outermost;
    }
    num++;
  }
}

alert(num);   //55
```

<a name="8-with-语句"></a>
#### 8. `with` 语句
`with` 语句的作用是将代码的作用域设置到一个特定的对象中。 `with` 语句的语法如下:

    with (expression) statement;

>由于大量使用 with 语句会导致性能下降,同时也会给调试代码造成困难,因此在开发大型应用程序时,不建议使用 with 语句

<a name="-9-switch-语句"></a>
####  9. `switch` 语句

    switch (expression) {
      case value: statement
        break;
      case value: statement
        break;
      case value: statement
        break;
      case value: statement
        break;
          default: statement
        }

`switch` 语句中的每一种情形(`case`)的含义是:“如果表达式等于这个值 (`value`),则执行后面的语句 (`statement`)”

>`switch` 语句在比较值时使用的是全等操作符,因此不会发生类型转换(例如,字符串 "10" 不等于数值 10)。

***

<a name="函数"></a>
## 函数

<a name="1-理解参数"></a>
#### 1. 理解参数
>* 命名的参数只提供便利,但不是必需的
* 没有传递值的命名参数将自动被赋予 undefined 值

<a name="2-没有重载"></a>
#### 2. 没有重载

<a name="引用类型"></a>
## 引用类型

<a name="date-类型"></a>
#### `Date` 类型

###### 日期/时间组件方法

|方法|说明|
|---|----|
|getTime()            |返回表示日期的毫秒数;与 valueOf() 方法返回的值相同|
|setTime( 毫秒 )        |以毫秒数设置日期,会改变整个日期|
|getFullYear()        |取得4位数的年份(如2007而非仅07)|
|getUTCFullYear()     |返回UTC日期的4位数年份|
|setFullYear( 年 )     |设置日期的年份。传入的年份值必须是4位数字(如2007而非仅07)|
|setUTCFullYear( 年 )  |设置UTC日期的年份。传入的年份值必须是4位数字(如2007而非仅07)|
|getMonth()           |返回日期中的月份,其中0表示一月,11表示十二月|
|getUTCMonth()        |返回UTC日期中的月份,其中0表示一月,11表示十二月|
|setMonth( 月 )        |设置日期的月份。传入的月份值必须大于0,超过11则增加年份|
|setUTCMonth( 月 )     |设置UTC日期的月份。传入的月份值必须大于0,超过11则增加年份|
|getDate()            |返回日期月份中的天数(1到31)|
|getUTCDate()         |返回UTC日期月份中的天数(1到31)|
|setDate( 日 )         |设置日期月份中的天数。如果传入的值超过了该月中应有的天数,则增加月份|
|setUTCDate( 日 )      |设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数,则增加月份|
|getDay()             |返回日期中星期的星期几(其中0表示星期日,6表示星期六)|
|getUTCDay()          |返回UTC日期中星期的星期几(其中0表示星期日,6表示星期六)|
|getHours()           |返回日期中的小时数(0到23)|
|getUTCHours()        |返回UTC日期中的小时数(0到23)|
|setHours( 时 )        |设置日期中的小时数。传入的值超过了23则增加月份中的天数|
|setUTCHours( 时 )     |设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数|
|getMinutes()         |返回日期中的分钟数(0到59)|
|getUTCMinutes()      |返回UTC日期中的分钟数(0到59)|
|setMinutes( 分 )      |设置日期中的分钟数。传入的值超过59则增加小时数|
|setUTCMinutes( 分 )   |设置UTC日期中的分钟数。传入的值超过59则增加小时数|
|getSeconds()         |返回日期中的秒数(0到59)|
|getUTCSeconds()      |返回UTC日期中的秒数(0到59)|
|setSeconds( 秒 )      |设置日期中的秒数。传入的值超过了59会增加分钟数|
|setUTCSeconds( 秒 )   |设置UTC日期中的秒数。传入的值超过了59会增加分钟数|
|getMilliseconds()    |返回日期中的毫秒数|
|getUTCMilliseconds() |返回UTC日期中的毫秒数|
|setMilliseconds( 毫秒 )|设置日期中的毫秒数|
|setUTCMilliseconds( 毫秒 )|设置UTC日期中的毫秒数|
|getTimezoneOffset()|返回本地时间与UTC时间相差的分钟数。例如,美国东部标准时间返回300。在某地进入夏令时的情况下,这个值会有所变化|
